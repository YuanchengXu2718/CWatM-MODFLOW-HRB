# ------------------------------------------------

######## ##          ##  ####  ######  ##    ##
##       ##          ## ##  ##   ##   ####  ####
##        ##        ##  ##  ##   ##   ## #### ##
##        ##   ##   ## ########  ##  ##   ##   ##
##         ## #### ##  ##    ##  ##  ##        ##
##         ####  #### ##      ## ## ##          ##
##########  ##    ##  ##      ## ## ##          ##

# Community Water Model Version 0.99
# SETTINGS FILE
# ------------------------------------------------

; by XYC
; verbose_GW = True
[OPTIONS]
#-------------------------------------------------------
# OPTION - to switch on/off

#-------------------------------------------------------

# Data otions
# if temperature is stored in Kelvin instead Celsius
TemperatureInKelvin = True
# if lat/lon the area has to be user defined = precalculated
gridSizeUserDefined = True

#-----------------------------------------------
# Evaporation: calculate pot. evaporation (True) or use precalculated pot.evaporation map stacks (False)
calc_evaporation = True

#-----------------------------------------------
# Irrigation and water demand

# if irrigation is included, otherwise paddy and non paddy is put into 'grassland'
includeIrrigation = True
static_irrigation_map = False
# if water demand from irrigation, industry and domestic is included
includeWaterDemand = True
includeIndusDomesDemand = True
# Water allocation
# if water demand and availability is calculated for region to compare demand vs. avail
usingAllocSegments = False
# limit abstraction to available groundwater (True) include fossil groundwater (False)
limitAbstraction = True

# by Yuancheng Xu, 2025/02/28
using_reservoir_command_areas = True

sectorSourceAbstractionFractions = True

# Environmental Flow
calc_environflow = False

#-----------------------------------------------
# Soil 
# use preferential flow, that bypasses the soil matrix and drains directly to the groundwater (not for irrPaddy)
preferentialFlow = True
# Capillar rise
CapillarRise = True

#-----------------------------------------------
# Routing

# if runoff concentration to the edge of a cell is included
includeRunoffConcentration = False
# Waterbodies like lakes and reservoirs
includeWaterBodies = True
# kinematic wave routing, if False no routing is calculated
includeRouting = True

#-----------------------------------------------
# Inflow from outside of the modelled area
inflow = False

# --- Reporting & Debugging ------------------- ----------------------------------------------
# Reporting options
writeNetcdfStack = True
reportMap = True
reportTss = True 
# Checking water balance (for debugging)
calcWaterBalance = False
sumWaterBalance = False
# use additional PCRaster GIS commands
PCRaster = False

modflow_coupling = True
use_complex_solver_for_modflow = True
#-------------------------------------------------------
# DEFINITIONS OF PARAMETERS
#-------------------------------------------------------

#-------------------------------------------------------
[FILE_PATHS]
#-------------------------------------------------------
PathRoot = ./
PathBase = ../

PathOut = $(FILE_PATHS:PathRoot)/output
PathMaps = $(FILE_PATHS:PathBase)/CWatM_data\cwatm_input_5min
Path_5min = $(FILE_PATHS:PathBase)/haihe_5min_V2
; PathMeteo = ../CWatM_data\GSWP3-W5E5
PathMeteo_5min = $(FILE_PATHS:PathBase)/haihe_5min_meteoV3

#-------------------------------------------------------
[NETCDF_ATTRIBUTES]
institution = IIASA
title = Rhine Water Model - WATCH WDFEI
metaNetcdfFile = $(FILE_PATHS:PathRoot)/cwatm/metaNetcdf.xml

#-------------------------------------------------------
# AREA AND OUTLETS
#-------------------------------------------------------
[MASK_OUTLET]

# Area mask
# A pcraster map, tif or netcdf map e.g.  $(FILE_PATHS:PathRoot)/data/areamaps/area_indus.map
# or a retancle: Number of Cols, Number of rows, cellsize, upper left corner X, upper left corner Y 
MaskMap = $(FILE_PATHS:Path_5min)\haihe_5min_new.tif

#---------------------------s_84----------------------------
# Station data
# either a map e.g. $(FILE_PATHS:PathRoot)/data/areamaps/area3.map
# or a location coordinates (X,Y) e.g. 5.75 52.25 9.25 49.75 )
# Lobith/Rhine
Gauges = 114.22	38.87 115.14 39.46 114.89 38.88

# if .tif file for gauges, this is a flag if the file is global or local
# e.g. Gauges = $(FILE_PATHS:PathRoot)/data/areamaps/gaugesRhine.tif
GaugesLocal = True
#-------------------------------------------------------
[TIME-RELATED_CONSTANTS]
#-------------------------------------------------------

# StepStart has to be a date e.g. 01/06/1990
# SpinUp or StepEnd either date or numbers 
# SpinUp: from this date output is generated (up to this day: warm up)

StepStart = 1/1/2000
SpinUp = 1/1/2005
StepEnd = 31/12/2024
#-------------------------------------------------------
[INITITIAL CONDITIONS]
#-------------------------------------------------------

# for a warm start initial variables a loaded
# e.g for a start on 01/01/2010 load variable from 31/12/2009
load_initial = True
initLoad = E:\CWatM24\CWatM-MODFLOW-HRB\init\init_CWatM.nc

# saving variables from this run, to initiate a warm start next run
# StepInit = saving date, can be more than one: 10/01/1973 20/01/1973
save_initial = False
save_init_water_table = False
initSave = E:\CWatM24\
StepInit = 31/12/2004

#-------------------------------------------------------
# CALIBARTION PARAMETERS
#-------------------------------------------------------
[CALIBRATION]

# These are parameter which are used for calibration
# could be any parameter, but for an easier overview, tehey are collected here
# in the calibration template a placeholder (e.g. %arnoBeta) instead of value

; PathCali = C:/Data/CWatM/calibration/lakevictoria5min

# hydrogeology
# porosity
poro_coef = 0.9840857852643902
# permeability coefficient
permeability_coef = 1.259313505802166

# Snow  
SnowMeltCoef = -0.0037568050912951617
# Cropf factor correction  
crop_correct =  1.8924183594612727
#Soil
soildepth_factor = 2.355779320317674
# soil_alpha used for KUnSat in Yang & Long (WRR, 2022), updated by Yuancheng Xu in Feb. 2024
soil_alpha = 13.525650307100383
preferentialFlowConstant = 6.948268751417286
arnoBeta_add = 0.1891377444701113
# interflow part of recharge factor = 1.0
factor_interflow = 1.8938075559319218
# groundwater recessionCoeff_factor = 1.0
; recessionCoeff_factor = %reces
# runoff concentration factor runoffConc_factor = 1.0
; runoffConc_factor = 0.1 
#Routing manningsN Factor to Manning's roughness = 1.0 [0.1-10.]
manningsN = 1.8228258546214238
; normalStorageLimit = %normRes
# lake parameter - factor to alpha: parameter of of channel width and weir coefficient  [0.33 - 3.] dafault 1.
lakeAFactor = 2.4720514766405626
# lake parameter - factor for wind evaporation
lakeEvaFactor = 1.1372849657108328
# coefficient for sealed fraction
sealedCoef = 0.6780330141001036
# return fraction of irrigation
irrigation_returnfraction = 0.16300719148389026
# by Yuancheng Xu
# new coefficient for intercept capacity
interceptCali = True
interceptCoef = 2.0925287697233825
# fraction of water supplied by reservoirs
resFrac = 0.5576257806683014

#-------------------------------------------------------
# TOPOGRAPHY MAPS
#-------------------------------------------------------
[TOPOP]
# local drain direction map (1-9)
; Ldd = $(FILE_PATHS:PathMaps)/routing/ldd.map
Ldd = $(FILE_PATHS:Path_5min)/routing/ldd_5min_V2.tif

# Elevation standard deviation [m], i.e. altitude difference elevation within pixel.
# Used for sub-pixel modelling of snow accumulation and melt
; ElevationStD = $(FILE_PATHS:PathMaps)/landsurface/topo/elvstd.map
ElevationStD = $(FILE_PATHS:Path_5min)/landsurface/topo/elvstd_haihe_5min.tif

# Area of pixel [m2] (for lat/lon every cell has a different area)
; CellArea = $(FILE_PATHS:PathMaps)/landsurface/topo/cellarea.nc            # original
CellArea =  $(FILE_PATHS:Path_5min)/routing/gridCellArea_haihe_5min.nc    

#-------------------------------------------------------
# INPUT METEOROLOGICAL TIMESERIES AS MAPS
#-------------------------------------------------------
[METEO]
# precipitation [m/day]
; PrecipitationMaps = $(FILE_PATHS:PathMeteo)/gswp3-w5e5_obsclim_pr*
PrecipitationMaps = $(FILE_PATHS:PathMeteo_5min)/pr_correct_*
# average daily temperature [K]
; TavgMaps = $(FILE_PATHS:PathMeteo)/gswp3-w5e5_obsclim_tas*
TavgMaps = $(FILE_PATHS:PathMeteo_5min)/tAvg*

# ----------------------------------------
# This is used if calc_evaporation = False

# daily reference evaporation (free water) 
; E0Maps = $(FILE_PATHS:PathMeteo)/EWRef_rhine.nc
#E0Maps = $(FILE_PATHS:PathMeteo)/EWRef_daily*
# daily reference evapotranspiration (crop) 
; ETMaps = $(FILE_PATHS:PathMeteo)/ETRef_rhine.nc
#ETMaps = $(FILE_PATHS:PathMeteo)/ETRef_daily*

# --------------------------------
# from kg m-2s-1 to m : 86.4
; precipitation_coversion = 86.4

# from m to m : 1
precipitation_coversion = 1

# from MM to m : 0.001
#precipitation_coversion = 0.001

evaporation_coversion = 1.00

# OUTPUT maps and timeseries
#OUT_Dir = $(FILE_PATHS:PathOut)
#OUT_MAP_Daily = Precipitation, prec1

#-------------------------------------------------------
# CALCULATE EVAPORATION - PENMAN - MONTEITH
#-------------------------------------------------------
[EVAPORATION]

# This is used if calc_evaporation = True
# use albedo maps
albedo = True
albedoMaps = $(FILE_PATHS:Path_5min)/landsurface/albedo_5min.nc 

# if not albedo maps use fixed albedo
# Albedo of bare soil surface (Supit et. al.)
AlbedoSoil = 0.15
# Albedo of water surface (Supit et. al.)
AlbedoWater = 0.05
# Albedo of vegetation canopy (FAO,1998)
AlbedoCanopy = 0.23

# use specific humidity (TRUE) QAir,  or relative humidity (FALSE) - rhs
useHuss = True

# map stacks Temperature [K}]
; TminMaps = $(FILE_PATHS:PathMeteo)/gswp3-w5e5_obsclim_tasmin*
TminMaps = $(FILE_PATHS:PathMeteo_5min)/tMin*
; TmaxMaps = $(FILE_PATHS:PathMeteo)/gswp3-w5e5_obsclim_tasmax*
TmaxMaps = $(FILE_PATHS:PathMeteo_5min)/tMax*
# Instantaneous surface pressure[Pa]
; PSurfMaps = $(FILE_PATHS:PathMeteo)/gswp3-w5e5_obsclim_ps*
PSurfMaps = $(FILE_PATHS:PathMeteo_5min)/Psurf*
# 2 m istantaneous specific humidity[kg /kg] (QAir) or relative humidity [%] (rhs)
#RhsMaps = $(FILE_PATHS:PathMeteo)/gswp3-w5e5_obsclim_huss*
; QAirMaps = $(FILE_PATHS:PathMeteo)/gswp3-w5e5_obsclim_hurs*
QAirMaps = $(FILE_PATHS:PathMeteo_5min)/huss*
# wind speed maps at 10m [m/s]
; WindMaps = $(FILE_PATHS:PathMeteo)/gswp3-w5e5_obsclim_sfcwind*
WindMaps = $(FILE_PATHS:PathMeteo_5min)/wind*
# radiation surface downwelling shortwave maps  [W/m2]
; RSDSMaps = $(FILE_PATHS:PathMeteo)/gswp3-w5e5_obsclim_rsds*
RSDSMaps = $(FILE_PATHS:PathMeteo_5min)/rsds*
# radiation surface downwelling longwave maps [W/m2] [W/m2]
; RSDLMaps = $(FILE_PATHS:PathMeteo)/gswp3-w5e5_obsclim_rlds*
RSDLMaps = $(FILE_PATHS:PathMeteo_5min)/rlds*

# OUTPUT maps and timeseries
#OUT_Dir = $(FILE_PATHS:PathOut)
#OUT_MAP_Daily = EWRef, ETRef, temp, prec

#-------------------------------------------------------
[SNOW]
#-------------------------------------------------------

# Number of vertical Snow layers
NumberSnowLayers = 7
# up to which layer the ice melt is calculated with the middle temperature
GlacierTransportZone = 3

# Temperature lapse rate with altitude [deg C / m]
TemperatureLapseRate = 0.0065 
# Multiplier applied to precipitation that falls as snow
SnowFactor = 1.0
# Range [m C-1 d-1] of the seasonal variation, SnowMeltCoef is the average value
SnowSeasonAdj = 0.001
# Average temperature at which snow melts
TempMelt = 1.0
# Average temperature below which precipitation is snow
TempSnow = -3.0
# Snow melt coefficient: default: 4.0 
# SRM: 0.0045 m/C/day ( = 4.50 mm/C/day), Kwadijk: 18 mm/C/month (= 0.59 mm/C/day)  
# See also Martinec et al., 1998.

# use in CALIBRATION -> copied to CALIBRATION
#SnowMeltCoef = 0.004
IceMeltCoef  = 0.007

#--------------------------------------------------------------
# INITIAL CONDITIONS - Initial snow depth in snow zone 1-7 [mm]  - SnowCoverIni

[FROST]
# Snow water equivalent, (based on snow density of 450 kg/m3) (e.g. Tarboton and Luce, 1996)
SnowWaterEquivalent = 0.45
# Daily decay coefficient, (Handbook of Hydrology, p. 7.28)
Afrost = 0.97
# Snow depth reduction coefficient, [cm-1], (HH, p. 7.28)
Kfrost = 0.57
# Degree Days Frost Threshold (stops infiltration, percolation and capillary rise)
# Molnau and Bissel found a value 56-85 for NW USA.
FrostIndexThreshold = 56

#--------------------------------------------------------------
# INITIAL CONDITIONS: FrostIndexIni

[VEGETATION]
; cropgroupnumber = $(FILE_PATHS:PathMaps)/soil/cropgrp.nc     # original
; cropgroupnumber = $(FILE_PATHS:PathMaps)/others/cropgrp_interpolation.nc
cropgroupnumber = $(FILE_PATHS:Path_5min)/cropgrp_5min.tif
# soil water depletion fraction, Van Diepen et al., 1988: WOFOST 6.0, p.86, Doorenbos et. al 1978

#-------------------------------------------------------
[SOIL]
#-------------------------------------------------------

PathTopo = $(FILE_PATHS:Path_5min)/landsurface
PathSoil = $(FILE_PATHS:Path_5min)/others


# Topography mapsNetcdf/maps
# tangent slope, slope length and orographybeta 
tanslope = $(FILE_PATHS:Path_5min)/tanslope_5min.tif
; slopeLength = $(PathTopo)/slopeLength.map # not used, Yuancheng Xu 2024/03/17

# maps of relative elevation above flood plains
; relativeElevation = $(PathTopo)/dzRel_5min_detrended.nc           # original
relativeElevation = $(PathTopo)/dzRel_5min.nc 

# Soil hydraulic properties

# soil (Hypres pedotransfer function - http://esdac.jrc.ec.europa.eu/ESDB_Archive/ESDBv2/popup/hy_param.htm)
# Alpha: an Genuchten’s shape parameter
#Lambda: an Genuchten’s shape parameter = n-1-> n = lamda+1, m = 1 - (1/n)
# thetas  is the volumetric water content θ saturated 
# thetar is the volumetric water content θ residual 

# soil (Rosetta pedotransfer function)      
KSat1 = $(PathSoil)/ksat1_5min.map   
KSat2 = $(PathSoil)/ksat2_5min.map   
KSat3 = $(PathSoil)/ksat2_5min.map   
# Alpha: an Genuchten’s shape parameter     
alpha1 = $(PathSoil)/alpha1_5min.map  
alpha2 = $(PathSoil)/alpha2_5min.map  
alpha3 = $(PathSoil)/alpha2_5min.map  
#Lambda: an Genuchten’s shape parameter = n-
lambda1 = $(PathSoil)/lambda1_5min.map
lambda2 = $(PathSoil)/lambda2_5min.map
lambda3 = $(PathSoil)/lambda2_5min.map
# thetas  is the volumetric water content θ 
# thetar is the volumetric water content θ residual
thetas1 = $(PathSoil)/thetas1_5min.map
thetas2 = $(PathSoil)/thetas2_5min.map
thetas3 = $(PathSoil)/thetas2_5min.map
# thetar is the volumetric water content θ residual
thetar1 = $(PathSoil)/thetar1_5min.map
thetar2 = $(PathSoil)/thetar2_5min.map
thetar3 = $(PathSoil)/thetar2_5min.map

; percolationImp = $(PathSoil)/percolationImp.map     # original
; percolationImp = $(FILE_PATHS:PathMaps)/landsurface/\soil\percolationImp_1km.nc
percolationImp = $(FILE_PATHS:Path_5min)/percolationImp_5min.tif

maxGWCapRise    = 5.0
minCropKC        = 0.2
minTopWaterLayer = 0.0

# Soil depth
StorDepth1 = $(FILE_PATHS:Path_5min)/firstStorDepth_5min.tif
StorDepth2 = $(FILE_PATHS:Path_5min)/secondStorDepth_5min.tif

# preferential flow (between 1.0 and 8.0)
# used in CALIBRATION -> copied to CALIBRATION
#preferentialFlowConstant = 4.0

#-------------------------------------------------------
[LANDCOVER]
PathLandcover = $(FILE_PATHS:Path_5min)/landsurface

coverTypes = forest, grassland, irrPaddy, irrNonPaddy, sealed, water
coverTypesShort = f, g, i, n, s, w
fractionLandcover = $(PathLandcover)/fracLandcover_PGong_5min.nc
# by Yuancheng Xu, 2025/02/27
# if sealedCali == True
# fracSealed_cali = sealedCoef * fracSealed
# fracGrass_cali = (1 - sealedCoef) * fracSealed + fracGrass
sealedCali = True
; sealedCoef = 0.7  # -> put into calibration

# Landcover can vary from year to year
dynamicLandcover = False
# if landcover cannot vary, which year should be taken as fixed year
fixLandcoverYear = 2010

#-------------------------------------------------------

[__forest]
PathForest = $(FILE_PATHS:Path_5min)/landcover/forest
PathSoil =  $(FILE_PATHS:Path_5min)/others

# Parameters for the Arno's scheme 
# arnoBeta is defined by orographic,+ land cover add + calibration add, the soil water capacity distribution is based on this 
# range [0.01 - 1.2]
forest_arnoBeta = 0.2

#forest_soil
forest_KSat1 = $(PathSoil)/Ksat1_5min.map
forest_KSat2 = $(PathSoil)/Ksat2_5min.map
forest_KSat3 = $(PathSoil)/Ksat2_5min.map
forest_alpha1 = $(PathSoil)/alpha1_5min.map
forest_alpha2 = $(PathSoil)/alpha2_5min.map
forest_alpha3 = $(PathSoil)/alpha2_5min.map
forest_lambda1 = $(PathSoil)/lambda1_5min.map
forest_lambda2 = $(PathSoil)/lambda2_5min.map
forest_lambda3 = $(PathSoil)/lambda2_5min.map
forest_thetas1 = $(PathSoil)/thetas1_5min.map
forest_thetas2 = $(PathSoil)/thetas2_5min.map
forest_thetas3 = $(PathSoil)/thetas2_5min.map
forest_thetar1 = $(PathSoil)/thetar1_5min.map
forest_thetar2 = $(PathSoil)/thetar2_5min.map
forest_thetar3 = $(PathSoil)/thetar2_5min.map
forest_fc1 = $(PathSoil)/WRR-FC_5min.map
forest_fc2 = $(PathSoil)/WRR-FC_5min.map
forest_fc3 = $(PathSoil)/WRR-FC_5min.map

# other paramater values
forest_minInterceptCap  = 0.001
forest_cropDeplFactor   = 0.0

; forest_fracVegCover  = $(PathForest)/fracVegCover.map
forest_rootFraction1 = $(PathForest)/rootFractionForest1_5min.tif
forest_rootFraction2 = $(PathForest)/rootFractionForest2_5min.tif
#forest_maxRootDepth  = 2.0
forest_maxRootDepth  = $(PathForest)/maxRootDepthForest_5min.tif
forest_minSoilDepthFrac = $(PathForest)/minSoilDepthFracForest_5min.tif


forest_cropCoefficientNC = $(PathForest)/ForestKC_5min.nc
forest_interceptCapNC    = $(PathForest)/interceptCapForest_5min.nc

# initial conditions: forest_interceptStor, forest_w1, forest_w2, forest_w3, 


[__grassland]
PathGrassland = $(FILE_PATHS:Path_5min)/landcover/grassland

# Parameters for the Arno's scheme: 
grassland_arnoBeta = 0.0
# arnoBeta is defined by orographic,+ land cover add + calibration add, the soil water capacity distribution is based on this
# range [0.01 - 1.2]

# other paramater values

grassland_minInterceptCap  = 0.001
grassland_cropDeplFactor   = 0.0

; grassland_fracVegCover  = $(PathGrassland)/fracVegCover.map
grassland_rootFraction1 = $(PathGrassland)/rfrac1_short_5min.tif
grassland_rootFraction2 = $(PathGrassland)/rfrac2_short_5min.tif
grassland_maxRootDepth  = $(PathGrassland)/maxRootDepthGrass_5min.tif
grassland_minSoilDepthFrac = $(PathGrassland)/minSoilDepthFracGrass_5min.tif


grassland_cropCoefficientNC = $(PathGrassland)/GrassKC_5min.nc
grassland_interceptCapNC    = $(PathGrassland)/interceptCapGrass_5min.nc

# initial conditions: grassland_interceptSto, grassland_w1, grassland_w2, grassland_w3


[__irrPaddy]
PathIrrPaddy = $(FILE_PATHS:Path_5min)/landcover/irrPaddy

# Parameters for the Arno's scheme:
irrPaddy_arnoBeta = 0.2
# arnoBeta is defined by orographic,+ land cover add + calibration add, the soil water capacity distribution is based on this
# range [0.01 - 1.2]

# other paramater values

irrPaddy_minInterceptCap  = 0.001
irrPaddy_cropDeplFactor   = 0.0

; irrPaddy_fracVegCover  = $(PathIrrPaddy)/fracVegCover.map
irrPaddy_rootFraction1 = $(PathIrrPaddy)/rfrac1_paddy_5min.tif
irrPaddy_rootFraction2 = $(PathIrrPaddy)/rfrac2_paddy_5min.tif

irrPaddy_maxRootDepth  = $(PathIrrPaddy)/PaddyMaxRootDepth_5min.tif
irrPaddy_minSoilDepthFrac = $(PathIrrPaddy)/PaddyMinSoilDepthFrac_5min.tif

irrPaddy_cropCoefficientNC = $(PathIrrPaddy)/irrPaddyKC_5min.nc
; irrPaddy_cropCoefficientNC = $(FILE_PATHS:Path_5min)/randomKC.nc

# maximum flooding depth for paddy
irrPaddy_maxtopwater = 0.05

[__irrNonPaddy]
PathIrrNonPaddy = $(FILE_PATHS:Path_5min)/landcover/irrNonPaddy

# Parameters for the Arno's scheme:
irrNonPaddy_arnoBeta = 0.2
# arnoBeta is defined by orographic,+ land cover add + calibration add, the soil water capacity distribution is based on this
# range [0.01 - 1.2]

# other paramater values


irrNonPaddy_minInterceptCap  = 0.001
irrNonPaddy_cropDeplFactor   = 0.0

; used if static_irrigation_map = True, seems to have errors. Not used since 2024/03/26 Yuancheng Xu
; irrNonPaddy_fracVegCover  = $(PathIrrNonPaddy)/maxf_nonpaddy_5min.tif     

irrNonPaddy_rootFraction1 = $(PathIrrNonPaddy)/rfrac1_nonpaddy_5min.tif 
irrNonPaddy_rootFraction2 = $(PathIrrNonPaddy)/rfrac2_nonpaddy_5min.tif 

irrNonPaddy_maxRootDepth  = $(PathIrrNonPaddy)/nonPaddyMaxRootDepth_5min.tif 
irrNonPaddy_minSoilDepthFrac = $(PathIrrNonPaddy)/nonPaddyMinSoilDepthFrac_5min.tif 


irrNonPaddy_cropCoefficientNC = $(PathIrrNonPaddy)/irrNonPaddyKC_5min.nc

# initial conditions: irrNonPaddy_interceptStor, irrNonPaddy_w1, irrNonPaddy_w2, irrNonPaddy_w3


[__sealed]
; PathSealed = $(FILE_PATHS:PathMaps)/landcover/sealed

sealed_minInterceptCap  = 0.003

# initial conditions: sealed_interceptStor


[__open_water]
; PathWater = $(FILE_PATHS:PathMaps)/landcover/water

water_minInterceptCap  = 0.0

#-------------------------------------------------------
[GROUNDWATER]
#-------------------------------------------------------

; PathGroundwater = $(FILE_PATHS:PathMaps)/groundwater
PathGroundwater = $(FILE_PATHS:Path_5min)\groundwater

recessionCoeff = $(PathGroundwater)/recessionCoeff_5min.tif
# baseflow = recessionCoeff * storage groundwater
specificYield = $(PathGroundwater)/specificYield_5min.tif
kSatAquifer = $(PathGroundwater)/kSatAquifer_5min.tif
# both not used at the moment in groundwater modul, but already loaded


#-------------------------------------------------------
[GROUNDWATER_MODFLOW]
#-------------------------------------------------------

#Executable Modflow file
path_mf6dll = $(FILE_PATHS:PathRoot)/Modflow6/mf6

# Path of Modflow input and output
PathGroundwaterModflow = $(FILE_PATHS:Path_5min)/MODFLOW_HRB
PathGroundwaterModflowOutput = $(PathGroundwaterModflow)/output

PathGroundwaterModflowInput = $(PathGroundwaterModflow)/input

# write modflow eror to file
writeModflowError = True

##  --- Steady state begin -----------------------
# soil humidity should not be high when starting to avoid to much pumping demand at the begining (between 0 and 1, 0.75 seems nice)
start_soil_humid = 0.5
# load an initial water table (in meter)
load_init_water_table = False
# if False, initial_water_table_depth (in m) is used on all the grid
#initial_water_table_depth = $(PathGroundwaterModflowInput)/modflow_depth0_totalend.nc; $(PathGroundwaterModflowInput)/modflow_depth1_totalend.nc
initial_water_table_depth = 10
# if True, init_water_table is the initial water table file (2D numpy format (row, col))
# Defining the upper limit of the groundwater layer
use_soildepth_as_GWtop = True
correct_soildepth_underlakes = True
depth_underlakes = 2

# Pumping file (a 3D numpy array where 1st dim is time, then, 1st col = ModFlow row index, 2nd col = ModFlow col index, 3rd col = pumping rates < 0 !!!! in m3/day)
Groundwater_pumping = True
# if ModFlow cells under the CWatM cell are less saturated than water_table_limit_for_pumping, we prevent pumping
water_table_limit_for_pumping = 0.2
#Updated from 0.5

#pump_location = 0;1

# timestep of every Modflow execution
modflow_timestep = 1

load_modflow_from_disk = False
# Number of layers
nlay = 1


# Data for specified resolution
cwatm_modflow_indices = $(PathGroundwaterModflowInput)
modflow_basin = $(PathGroundwaterModflowInput)/modflow_basin.tif
; topo_modflow = $(PathGroundwaterModflowInput)/elevation_modflow.tif
topo_modflow = $(PathGroundwaterModflowInput)/elevation_32650_HRB_5km.tif
; chanRatio = $(PathGroundwaterModflowInput)/modflow_river_percentage.tif
chanRatio = $(PathGroundwaterModflowInput)/HRB_chanRatio_5km.tif


PathGroundwaterModflowHydrogeo = $(PathGroundwaterModflow)/hydrogeo_parameter

# We assume a confined aquifer, the unique parameters are transmissivity, porosity and thickness
# Processing thickness map for ModFlow-Flopy format #
# Thickness (default = 400) otherwise use maps from Gleeson et al.
thickness =  $(PathGroundwaterModflowHydrogeo)/thickness-M15PCao-lpf-V3.tif
# Processing porosity map for ModFlow-Flopy format (default = 0.1)
poro = $(PathGroundwaterModflowHydrogeo)/sy_utm_lpf.tif
; poro = 0.1
#Processing permeability map for ModFlow-Flopy format (default = 10E-5)
# unit: m/s
permeability = $(PathGroundwaterModflowHydrogeo)/kh_utm_lpf.tif
permeability_vertical = $(PathGroundwaterModflowHydrogeo)/kv_utm_lpf.tif
specific_storage = 5e-5
; specific_storage = $(PathGroundwaterModflowHydrogeo)/ss_utm.tif

# leakage under lake and rivers in m/day
leakageriver_permea = 0.05
leakagelake_permea = 0.05

#-------------------------------------------------------
[WATERDEMAND]
#-------------------------------------------------------

PathWaterdemand = $(FILE_PATHS:Path_5min)/landsurface/waterDemand

# For water demand vs. availability: areas have to be aggregated
# Allocation map

# Demand in m/day [True] (default) or as mio m3 per year or month [False]
demand_unit = True

# Demand data monthly or yearly, as  m day-1 or mio m3 per month
# for those in 55 once used by YWT, m day-1    by Yuancheng Xu, 2024/03/28
domesticWaterDemandFile = $(PathWaterdemand)/dom-2000_2024_5min_V2.nc

# time = True for monthly, False for yearly
domesticTimeMonthly = True
# name of the variable Withrawal = Gross, consumption = Netto
domesticWithdrawalvarname = domesticWithdrawal
domesticConsuptionvarname = domesticConsumption

industryWaterDemandFile = $(PathWaterdemand)/ind-2000_2024_5min_V2.nc
industryTimeMonthly = True
industryWithdrawalvarname = industryWithdrawal
industryConsuptionvarname = industryConsumption

useAgrDemand = True
irrWithdrawalvarname = agrWithdrawal
irrWaterDemandFile = $(PathWaterdemand)/agr-2000_2024_5min_V2.nc

uselivestock = False
livestockWaterDemandFile = $(PathWaterdemand)/historical_liv_year_millionm3_5min_1961_2010.nc
livestockTimeMonthly = False
livestockvarname = livestockConsumption

#----------------------------------------------------------------------------------
# by Yuancheng Xu, 2024/10/26
# updated by Yuancheng Xu on 2025/02/02 for SNWD-C

# unit of diverted water: km3
PathDiv = $(FILE_PATHS:Path_5min)/diversion

includeDiversionYellow = True

AbstractionFraction_DivYellow_Domestic = 0.7
AbstractionFraction_DivYellow_Livestock = 1
AbstractionFraction_DivYellow_Industry = 0.7
AbstractionFraction_DivYellow_Irrigation = 0.7

maskDivYellow = $(PathDiv)/div-yellow-5min-V3-250829.tif
DivYelTimeInterval = yearly
DivYellowFile = $(PathDiv)/div-yellow-year-V3-250829.xlsx

includeDiversionSNWDC = True

AbstractionFraction_DivSNWDC_Domestic = 0.7
AbstractionFraction_DivSNWDC_Livestock = 1
AbstractionFraction_DivSNWDC_Industry = 0.7
AbstractionFraction_DivSNWDC_Irrigation = 0

includeReplenSNWDC = True
; ReplenPoints = 114.51 38.16
ReplenPoints = 114.51 38.16 114.32 36.39 114.44 37.03 114.74 38.41 114.89 38.63 115.41 39.2 115.47 39.36 115.78 39.49 114.53 37.4

maskDivSNWDC = $(PathDiv)/div-SNWDC-5min-V2-250819.tif
DivSNWDCTimeInterval = yearly
DivSNWDCFile = $(PathDiv)/div-SNWDC-year-V2-250819.xlsx

includeWastewater = True
recycleFrac = E:\CWatM24\CWatM-MODFLOW-HRB\in\recycleFrac_year.txt
wwtAbstractionFraction_Domestic = 0.02
wwtAbstractionFraction_Livestock = 0
wwtAbstractionFraction_Industry = 0.3
wwtAbstractionFraction_Irrigation = 0

# fraction of groundwater abstraction from confined aquifers
includeConfinedAbs = True
confinedFrac = E:\CWatM24\CWatM-MODFLOW-HRB\in\confinedFrac_year.txt

# using environmental flow (EF) (per month) as input value
# EF will be treated as one part of overall water demand
use_environflow = False
EnvironmentalFlowFile = $(FILE_PATHS:PathOut)/MQ90_12month.nc

irrNonPaddy_efficiency = 0.7
irrPaddy_efficiency = 0.6
; irrigation_returnfraction = 0.3 -> to calibration

swAbstractionFraction_Channel_Domestic = 0.05
swAbstractionFraction_Channel_Livestock = 0
swAbstractionFraction_Channel_Industry = 0.05
swAbstractionFraction_Channel_Irrigation = 0.3

swAbstractionFraction_Lake_Domestic = 1
swAbstractionFraction_Lake_Livestock = 1
swAbstractionFraction_Lake_Industry = 1
swAbstractionFraction_Lake_Irrigation = 1

swAbstractionFraction_Res_Domestic = 0.5576257806683014
swAbstractionFraction_Res_Livestock = 0
swAbstractionFraction_Res_Industry = 0.5576257806683014
swAbstractionFraction_Res_Irrigation = 0.5576257806683014

gwAbstractionFraction_Domestic = 1
gwAbstractionFraction_Livestock = 1
gwAbstractionFraction_Industry = 1
gwAbstractionFraction_Irrigation = 1

# -----------------------------------------------------------
# Estimate of fractions of groundwater and surface water abstractions
# Either a fixed fraction for surface water abstration
# based on fraction of average baseflow and upstream average discharge 
# if swAbstractionFrac < 0: fraction is taken from baseflow / discharge 
# if swAbstractionFrac > 0 this value is taken as a fixed value 
; swAbstractionFrac = 0.9
; averageDischarge = $(FILE_PATHS:PathOut)/discharge_totalavg_rhine30min.nc
# in [m3/s]
; averageBaseflow  = $(FILE_PATHS:PathOut)/baseflow_totalavg_rhine30min.nc
# in [m3/s]
; baseflowInM = True
# if baseflow is in [m] instead of [m3/s] it will be converted


#-------------------------------------------------------
# RUNOFF CONCENTRATION
#-------------------------------------------------------
[RUNOFF_CONCENTRATION]

# using triagular weigthning method
# the bigger the factor, more lag time 
forest_runoff_peaktime = 1.0
grassland_runoff_peaktime = 0.5
irrPaddy_runoff_peaktime = 0.5
irrNonPaddy_runoff_peaktime = 0.5
sealed_runoff_peaktime = 0.15 
water_runoff_peaktime = 0.01

interflow_runoff_peaktime =1.0
baseflow_runoff_peaktime = 2.0

# initial conditions:
# here only 1 layer is shown, but there are up to 10: runoff_concIni


#-------------------------------------------------------
# ROUTING MAPS and PARAMETERSD
#-------------------------------------------------------
[ROUTING]

PathRouting = $(FILE_PATHS:PathMaps)/routing

# Number of substep per day
# should be 10 for 0.5 deg but 24 for 0.1 deg

NoRoutingSteps = 10
#kinematic wave parameter: 0.6 is for broad sheet flow
chanBeta = 0.6

# Channel gradient (fraction, dy/dx)
chanGrad = $(PathRouting)/kinematic/changradient.nc
# Minimum channel gradient (for kin. wave: slope cannot be 0)
chanGradMin = 0.0001

#Channel Manning's n
chanMan = $(PathRouting)/kinematic/chanmanning.nc
#Channel length [meters]
chanLength = $(PathRouting)/kinematic/chanlength.nc
#Channel bottom width [meters]
chanWidth = $(PathRouting)/kinematic/chanwidth_null1.tif
#Bankfull channel depth [meters]
chanDepth = $(PathRouting)/kinematic/chanheight_null1.tif

# initial conditions: channelStorageIni, riverbedExchangeIni, dischargeIni  

#-------------------------------------------------------
# LAKES AND RESERVOIRS
#-------------------------------------------------------
[LAKES_RESERVOIRS]

PathLakesRes = $(FILE_PATHS:Path_5min)/routing/lakesreservoirs

# Use reservoirs and lakes (otherwise use only lakes Lake ID=1 and 3 => natural conditions)
useResAndLakes = True
# Reservoirs do have a year of implementation
dynamicLakesRes = True
# if Reservoirs does not have a year of implemtation, which year should be taken as fixed year
fixLakesResYear = 1961


#----------------------------
#Big lakes and Reservoirs

# ID of every lake, reservoir from HydroLakes database
waterBodyID = $(PathLakesRes)/lakesResID_5min.tif
# 1 for lake, 2 for reservoir, 3 for lake and reservoir
waterBodyTyp = $(PathLakesRes)/lakesResType_5min.tif
# Avergae discharge from HydroLakes Database
waterBodyDis = $(PathLakesRes)/lakesResDis_5min.tif

# Lakes surface area from HydroLakes Database
waterBodyArea = $(PathLakesRes)/lakesResArea_5min.tif
# a factor to scale the outlet of a lake
#lakeAFactor = 1.0  -> calibration

reservoir_command_areas = $(FILE_PATHS:Path_5min)/routing/lakesreservoirs/Res_command_250827.tif

#----------------------------
# Small lakes and reservoirs

useSmallLakes = False

; smallLakesRes = $(PathLakesRes)/smallLakesRes_1km.nc
; smallwaterBodyDis = $(PathLakesRes)/smallLakesResDis_1km.nc

# averageRunoff in [m] (if not given smallwaterBodyDis is taken instead)
#averageRunoff  = $(FILE_PATHS:PathOut)/runoff_totalavg_cali.nc

# for water demand
#min storage in [m3] (if not give it is calculated)
#minStorage  = $(FILE_PATHS:PathOut)/minsmalllakeStorage_cali.nc


# initial conditions: lakeInflowIni, lakeStorageIni, outLakeIni, lakeOutflowIni, reservoirStorageIni 

#------------------
# Reservoirs
# reservoir volume from HydroLakes database
waterBodyVolRes = $(PathLakesRes)/lakesResVolRes_5min.tif
# reservoir starting year from HydroLakes database 
waterBodyYear = $(PathLakesRes)/lakesResYear_5min.tif

#  Conservative, normal and flood storage limit (fraction of total storage, [-])
conservativeStorageLimit = 0.15
normalStorageLimit = 0.7
# --> put into calibration
floodStorageLimit = 0.9
# adjusting the balance between normal and flood storage
# [0 ..1]  0: NormalstorageLimit      1: (= closer to flood) results in keeping the normal qoutflow longer constant
adjust_Normal_Flood = 0.5

# Minimum, Normal and Non-damaging reservoir outflow  (fraction of average discharge, [-])
MinOutflowQ = 0.05
NormalOutflowQ = 1.0
NonDamagingOutflowQ = 4.0

# initial conditions: lakeInflowIni, lakeStorageIni, outLakeIni, lakeOutflowIni, reservoirStorageIni 


#-------------------------------------------------------
[INFLOW]
#-------------------------------------------------------

# if option inflow = true
# the inflow from outside is added at inflowpoints
In_Dir = $(FILE_PATHS:PathRoot)/in

# nominal map with locations of (measured)inflow hydrographs [cu m / s]
; InflowPoints = $(In_Dir)/in.map
; InflowPoints = 114.72571 38.40377 114.87723	38.62453 115.11017 38.89596

# if InflowPoints is a map, this flag is to identify if it is global (False) or local (True)
# observed or simulated input hydrographs as time series [cu m / s]
# Note: that identifiers in time series have to correspond to InflowPoints
# can be several timeseries in one file or different files e.g. main.tss mosel.tss
#QInTS = main1.tss mosel1.tss
; QInTS = mm.tss



#-------------------------------------------------------
[ENVIRONMENTALFLOW]
#-------------------------------------------------------

# Either calculate without run with predone discharge (set calc_ef_after = False)
calc_ef_after = True
# Or calculate after run (set calc_ef_after = False) and defining the file to be used
EFDis = $(FILE_PATHS:PathOut)/discharge_rhine.nc

# if predone discharge, do the maps need to be cut to fit to the mask?
cut_ef_map = False

# MAF: Mean, Q90: percentile 90, MMF: monthly average, MQ90: monthly Q90 9averagwed over al Jan, Feb..
# EF_VMF: Environmental flow - variable monthly flow, EF_VMF_LIH - EF- variable monthly flow, high intermediate, low class
OUT_Dir = $(FILE_PATHS:PathOut)
#OUT_MAP_Once = MAF, Q90
#OUT_MAP_12month = MMF, MQ90, EF_VMF, EF_VMF_LIH
#OUT_MAP_12month = MQ90, EF_VMF



#+++++++++++++++++++++++++++++++++++++++++++++++++++++++
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++


[OUTPUT]

# OUTPUT maps and timeseries
OUT_Dir = $(FILE_PATHS:PathOut)

OUT_MAP_MonthAvg = depth0, discharge
; OUT_MAP_MonthTot = sum_gwRecharge_actualM, modfPumpingM, ReplenM3_wwt, ReplenM3_SNWDC, act_DivYel
; OUT_MAP_MonthAvg = depth0, discharge, ReplenM3, tws, totalSto, lakeReservoirStorage, channelStorage
; OUT_MAP_MonthTot = flow_x, flow_y, sum_actualET, totalET, sum_gwRecharge_actualM, modfPumpingM, confinedPumping, sum_perc3toGW, sum_prefFlow, act_SurfaceWaterAbstract, act_indWithdrawal, act_domWithdrawal, act_DivYel, act_irrNonpaddyWithdrawal, act_DivSNWDC, Suf_Domestic, Suf_Industry, Suf_Irrigation, wwt_Domestic, wwt_Industry, GW_Domestic, GW_Industry, GW_Irrigation, DivYel_Domestic, DivYel_Industry, DivYel_Irrigation, DivSNWDC_Domestic, DivSNWDC_Industry, ReplenM3_SNWDC, ReplenM3_wwt